
```
给定一个数组 `nums`，编写一个函数将所有 `0` 移动到数组的末尾，同时保持非零元素的相对顺序。

**请注意** ，必须在不复制数组的情况下原地对数组进行操作。

**示例 1:**

**输入:** nums = `[0,1,0,3,12]`
**输出:** `[1,3,12,0,0]`

**示例 2:**

**输入:** nums = `[0]`
**输出:** `[0]`
```
其实这道题并没有那么简单
这里最好做到两点：
1. 不占用额外的空间空间复杂度O(1)
2. 只遍历一次(时间复杂度O(n))

   我们这里遍历的时候只会遇到两种情况：为0 和 非0
而我们希望为0的全在数组的右侧，而这个问题可以转化成任何非0元素应当排在数组的左侧
即：从左向右遍历，遇到非0元，就将其放在数组的左侧
而为了保持非0元之间的数据不变，当遇到第二个非0元，就需要将它放在数组左侧，同时又需要放在第一个非0元的右侧
这里就出现一个经典的问题了：
1. ***我需要从左往右遍历数组***
2. ***我需要维护左侧已经放好的非0元***
既需要遍历，又需要维护，很容易想到双指针的思想，用left去维护左侧，right去遍历右侧
核心代码：
```
int left, right = 0;
while(right < n)// right需要遍历完数组
{
   if(nums[right])//如果是非0元，就要放到左侧，把0放到当前非0元的位置
   {
   swap(nums[left],nums[right]);
   left++;//为了让下一个非0元在第一个非0元的右侧
   }
   right++;//继续向后遍历
}
