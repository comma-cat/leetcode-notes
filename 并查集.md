# 并查集
## 3532.针对图的路径存在性查询 I
```
class UnionFind {
//一个很重要的技巧，当你想要在类中使用函数，但是函数所需要的参数又在一个成员函数内时，直接在类中定义函数难以访问成员函数里的参数---这时就可以新定义一个类，在那个成员函数中创建新的类的对象，借用该对象来使用函数
   
public:

    vector<int> fa;

    UnionFind(int n) : fa(n) {

        ranges::iota(fa, 0);

    }

    int find(int x) {

        int root = x;

        // 找到根节点

        while(root != fa[root]) {

            root = fa[root];

        }

        // 路径压缩

        while(x != root) {

            int next = fa[x];

            fa[x] = root;

            x = next;

        }//这里是扁平化不使用递归，也不使用数组的技巧，只使用两个变量，可以避免递归导致栈溢出，也可以避免使用大数组而申请额外的空间，这里空间复杂度是O(1)

        return root;

    }

    bool isSameSet(int x, int y) {

        return find(x) == find(y);

    }

    void unionSet(int x, int y) {

        int fx = find(x);

        int fy = find(y);

        if(fx != fy) {

            fa[fx] = fy;

        }

    }

};

  

class Solution {

public:

    vector<bool> pathExistenceQueries(int n, vector<int>& nums, int maxDiff, vector<vector<int>>& queries) {

        UnionFind uf(n);

        // ***因为数组是单调不减的，只需连接相邻且差值 <= maxDiff 的节点***
        //这里是本题目的关键

        for(int i = 0; i < n - 1; i++) {

            if(nums[i + 1] - nums[i] <= maxDiff) {

                uf.unionSet(i, i + 1);

            }

        }

        // 处理查询

        vector<bool> ans(queries.size());

        for(int i = 0; i < queries.size(); i++) {

            ans[i] = uf.isSameSet(queries[i][0], queries[i][1]);

        }

        return ans;

    }

};
```
# 双指针
## 283.移动零
```
给定一个数组 `nums`，编写一个函数将所有 `0` 移动到数组的末尾，同时保持非零元素的相对顺序。

**请注意** ，必须在不复制数组的情况下原地对数组进行操作。

**示例 1:**

**输入:** nums = `[0,1,0,3,12]`
**输出:** `[1,3,12,0,0]`

**示例 2:**

**输入:** nums = `[0]`
**输出:** `[0]`
```
其实这道题并没有那么简单
这里最好做到两点：
1. 不占用额外的空间空间复杂度O(1)
2. 只遍历一次(时间复杂度O(n))

   我们这里遍历的时候只会遇到两种情况：为0 和 非0
而我们希望为0的全在数组的右侧，而这个问题可以转化成任何非0元素应当排在数组的左侧
即：从左向右遍历，遇到非0元，就将其放在数组的左侧
而为了保持非0元之间的数据不变，当遇到第二个非0元，就需要将它放在数组左侧，同时又需要放在第一个非0元的右侧
这里就出现一个经典的问题了：
1. ***我需要从左往右遍历数组***
2. ***我需要维护左侧已经放好的非0元***
既需要遍历，又需要维护，很容易想到双指针的思想，用left去维护左侧，right去遍历右侧
核心代码：
```
int left, right = 0;
while(right < n)// right需要遍历完数组
{
   if(nums[right])//如果是非0元，就要放到左侧，把0放到当前非0元的位置
   {
   swap(nums[left],nums[right]);
   left++;//为了让下一个非0元在第一个非0元的右侧
   }
   right++;//继续向后遍历
}
```

