
# 3532.针对图的路径存在性查询 I---并查集
```
class UnionFind {
//一个很重要的技巧，当你想要在类中使用函数，但是函数所需要的参数又在一个成员函数内时，直接在类中定义函数难以访问成员函数里的参数---这时就可以新定义一个类，在那个成员函数中创建新的类的对象，借用该对象来使用函数
   
public:

    vector<int> fa;

    UnionFind(int n) : fa(n) {

        ranges::iota(fa, 0);

    }

    int find(int x) {

        int root = x;

        // 找到根节点

        while(root != fa[root]) {

            root = fa[root];

        }

        // 路径压缩

        while(x != root) {

            int next = fa[x];

            fa[x] = root;

            x = next;

        }//这里是扁平化不使用递归，也不使用数组的技巧，只使用两个变量，可以避免递归导致栈溢出，也可以避免使用大数组而申请额外的空间，这里空间复杂度是O(1)

        return root;

    }

    bool isSameSet(int x, int y) {

        return find(x) == find(y);

    }

    void unionSet(int x, int y) {

        int fx = find(x);

        int fy = find(y);

        if(fx != fy) {

            fa[fx] = fy;

        }

    }

};

  

class Solution {

public:

    vector<bool> pathExistenceQueries(int n, vector<int>& nums, int maxDiff, vector<vector<int>>& queries) {

        UnionFind uf(n);

        // ***因为数组是单调不减的，只需连接相邻且差值 <= maxDiff 的节点***
        //这里是本题目的关键

        for(int i = 0; i < n - 1; i++) {

            if(nums[i + 1] - nums[i] <= maxDiff) {

                uf.unionSet(i, i + 1);

            }

        }

        // 处理查询

        vector<bool> ans(queries.size());

        for(int i = 0; i < queries.size(); i++) {

            ans[i] = uf.isSameSet(queries[i][0], queries[i][1]);

        }

        return ans;

    }

};
```


