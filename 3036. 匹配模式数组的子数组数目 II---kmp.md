# 题目描述
给你一个下标从 **0** 开始长度为 `n` 的整数数组 `nums` ，和一个下标从 `0` 开始长度为 `m` 的整数数组 `pattern` ，`pattern` 数组只包含整数 `-1` ，`0` 和 `1` 。

大小为 `m + 1` 的子数组 `nums[i..j]` 如果对于每个元素 `pattern[k]` 都满足以下条件，那么我们说这个子数组匹配模式数组 `pattern` ：

- 如果 `pattern[k] == 1` ，那么 `nums[i + k + 1] > nums[i + k]`
- 如果 `pattern[k] == 0` ，那么 `nums[i + k + 1] == nums[i + k]`
- 如果 `pattern[k] == -1` ，那么 `nums[i + k + 1] < nums[i + k]`

请你返回匹配 `pattern` 的 `nums` 子数组的 **数目** 。

**示例 1：**

**输入：**nums = [1,2,3,4,5,6], pattern = [1,1]
**输出：**4
**解释：**模式 [1,1] 说明我们要找的子数组是长度为 3 且严格上升的。在数组 nums 中，子数组 [1,2,3] ，[2,3,4] ，[3,4,5] 和 [4,5,6] 都匹配这个模式。
所以 nums 中总共有 4 个子数组匹配这个模式。

**示例 2：**

**输入：**nums = [1,4,4,1,3,5,5,3], pattern = [1,0,-1]
**输出：**2
**解释：**这里，模式数组 [1,0,-1] 说明我们需要找的子数组中，第一个元素小于第二个元素，第二个元素等于第三个元素，第三个元素大于第四个元素。在 nums 中，子数组 [1,4,4,1] 和 [3,5,5,3] 都匹配这个模式。
所以 nums 中总共有 2 个子数组匹配这个模式。
# code
```
class Solution {
public:
vector<int> transform(vector<int>& nums)
{
    int n = nums.size();
    vector<int> newArray(n-1,0);
    for(int i = 0 ; i < n - 1 ; i++)
    {
        if(nums[i+1] > nums[i])
        {
            newArray[i] = 1;
        }
        else if(nums[i+1] == nums[i])
        {
           newArray[i] = 0;
        }
        else
        {
            newArray[i] = -1;
        }
    }
    return newArray;
}
vector<int> getNext(vector<int>& nums)
{
   int n = nums.size();
   vector<int> next(n+1,0);
   if(n == 0) return next;
   next[0] = -1;
   if(n == 1) return next;
   next[1] = 0;
   int j = 0;
   for(int i = 2 ; i <= n ; i++)
   {
        while(j != -1 && nums[i-1] != nums[j])
        {
           j = next[j];
        }
        next[i] = j + 1;
        j = next[i];
   }
   return next;
}
int kmp(vector<int>&a,vector<int>&b)
{
    int ct = 0;
    int n = a.size();
    int m = b.size();
    vector<int> next = getNext(b);
    int x = 0 , y = 0;
    while(x < n)
    {
        if(a[x] == b[y])
        {
            x++;
            y++;
        }
        else if(y > 0)
        {
            y = next[y];
        }
        else
        {
            x++;
        }
        if(y == m)
        {
            ct++;
            y = next[m];
        }
    }
    return ct;
}

    int countMatchingSubarrays(vector<int>& nums, vector<int>& pattern) {

        int n = nums.size();

        int m = pattern.size();

        vector<int> arr = transform(nums);//主串

        return kmp(arr,pattern);

    }      

};

//实际上就是将主串进行转换，再和字串匹配
};
```

关键：transform是将大小为n的原数组根据规则转换成一个新数组arr
      那么原问题就变成了这个pattern数组与这个新数组arr之间的KMP匹配问题